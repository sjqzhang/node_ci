{
  "name": "mysql-activerecord",
  "version": "0.8.6",
  "author": {
    "name": "Martin Tajur",
    "email": "martin@tajur.ee"
  },
  "description": "A lightweight MySQL query builder on top of the node-mysql module.",
  "homepage": "https://github.com/martintajur/node-mysql-activerecord",
  "repository": {
    "type": "git",
    "url": "git://github.com/martintajur/node-mysql-activerecord.git"
  },
  "contributors": [
    {
      "name": "Daniel Bretoi",
      "email": "daniel@bretoi.com"
    },
    {
      "name": "Kyle Farris",
      "email": "kyle@chomponllc.com"
    },
    {
      "name": "Daehyub Kim",
      "email": "lateau@gmail.com"
    }
  ],
  "dependencies": {
    "mysql": "2.5.2"
  },
  "main": "./",
  "engines": {
    "node": "*"
  },
  "readme": "MySQL ActiveRecord Adapter for Node.js\n======================================\n\nQuery builder on top of node-mysql module (https://github.com/felixge/node-mysql).\n\nTo me, the main benefit of  is the ability to direct JavaScript objects straight to MySQL query components without having to worry about constructing the query itself. Although this query builder is a tiny step towards an ORM, I see a lot of value in the query builder as it allows more control over database queries than traditional ORM where queries are hidden behind the business logic and may become executed in an unoptimized way. (It is named after a popular PHP framework CodeIgniter's \"Active Record\" class, and thus the whole library does not have much in common with the active record pattern as such.)\n\nThis query builder is\n \n * Light-weight\n * Supports all basic MySQL commands\n * Supports method chaining\n * Automatically escapes field values\n * Has no dependencies (it already includes the node-mysql module)\n * Supports raw queries\n\nHow to install\n==============\n\n\tnpm install mysql-activerecord\n\n\nGet started\n-----------\n\n\tvar Db = require('mysql-activerecord');\n\tvar db = new Db.Adapter({\n\t\tserver: 'localhost',\n\t\tusername: 'root',\n\t\tpassword: '12345',\n\t\tdatabase: 'test',\n\t\treconnectTimeout: 2000\n\t});\n\n * `server`: the IP address or hostname to connect to\n * `username`: MySQL username to connect with\n * `password`: MySQL password to connect with\n * `database`: database to switch to initially (optional). If omitted, no database will be selected.\n * `port`: which port to connect to (optional). If omitted, 3306 will be used.\n * `reconnectTimeout`: milliseconds after which to try to reconnect to the MySQL server if a disconnect happens (optional). If omitted, the default value of 2000 will be used. If set to `false`, no reconnecting will take place.\n\nSupport of MySQL commands\n=========================\n\n * SELECT\n * UPDATE\n * INSERT (single-row and multi-row)\n * INSERT IGNORE\n * DELETE\n * JOIN\n * LIMIT and OFFSET\n * ORDER BY\n * GROUP BY\n * COUNT\n * HAVING\n\nMethods\n=======\n\n# .select()\n\n## .select(selectFieldName)\nSpecifies the field(s) to use in the SELECT query as a atring.\n\n\tdb.select(\"id, CONCAT(first_name, ' ', last_name) as full_name, email\");\n\t// This would produce: SELECT id, CONCAT(first_name, ' ', last_name) as full_name, email …\n\nYou can call .select() multiple times within the scope of one query — all parameters will be used in the final query. E.g.\n\n\tdb.select('id');\n\t// do some advanced checking and calculations here (only synchronous work, though!)\n\tdb.select('first_name, last_name');\n\t// This would procude: SELECT id, first_name, last_name …\n\n## .select([selectFieldName, selectFieldName, … ])\nSame as above, with a difference of taking in fields list as an array.\n\n\tdb.select(['id', 'first_name', 'last_name']);\n\t// This would produce: SELECT id, first_name, last_name …\n\n# .where()\n\n## .where(rawClause)\nSpecifies a where clause component.\n\n\tdb.where('add_time is null');\n\t// This would produce: … WHERE add_time is null …\n\nYou can call .where() multiple times within the scope of one query — all parameters will be used in the final query.\n\n## .where(fieldName, [possibleWhereInValue, possibleWhereInValue])\nSpecifies a WHERE IN structure to use in the query.\n\n\tdb.where('first_name', ['John', 'Maria', 'Jason', 'Herbert']);\n\t// This would produce: … WHERE first_name in ('John', 'Maria', 'Jason', 'Herbert') …\n\n## .where(fieldName, fieldValue)\nSpecifies a single WHERE condition to use in the query.\n\n\tdb.where('first_name', 'John');\n\t// This would produce: … WHERE first_name = 'John' …\n\n## .where({ fieldName: fieldValue, fieldName: fieldValue, … })\nSpecifies multiple WHERE conditions to use in the query.\n\n\tvar conditions = {\n\t\tfirst_name: 'John',\n\t\tlast_name: 'Smith'\n\t};\n\tdb.where(conditions);\n\t// This would produce: … WHERE first_name = 'John' AND last_name = 'Smith' …\n\n# .order_by()\n\n## .order_by(orderByCondition)\nSpecifies the ORDER BY condition as a full string.\n\n\tdb.order_by('name asc');\n\t// This would produce: … ORDER BY name asc …\n\nYou can call .order_by() multiple times within the scope of one query — all parameters will be used in the final query.\n\n## .order_by([orderByCondition, orderByCondition, … ])\nSpecifies multiple ORDER BY conditions as an array.\n\n\tdb.order_by(['name asc', 'last_name desc']);\n\t// This would produce: … ORDER BY name asc, last_name desc …\n\n# .group_by()\n\n## .group_by(groupByCondition)\nSpecifies the GROUP BY condition as a full string.\n\n\tdb.group_by('name asc');\n\t// This would produce: … GROUP BY name asc …\n\nYou can call .group_by() multiple times within the scope of one query — all parameters will be used in the final query.\n\n## .group_by([groupByCondition, groupByCondition, … ])\nSpecifies the GROUP BY condition as a full string.\n\n\tdb.group_by(['name asc', 'last_name desc']);\n\t// This would produce: … GROUP BY name asc, last_name desc …\n\n# .join()\n\n## .join(tableName, joinCondition, joinDirection)\nJoin additional tables to the query.\n\n\tdb.join('pets', 'pets.owner_id = people.id', 'LEFT');\n\t// This would produce: … LEFT JOIN pets ON pets.owner_id = people.id …\n\n\tdb.join('pets', 'pets.owner_id = people.id');\n\t// This would produce: … JOIN pets ON pets.owner_id = people.id …\n\n# .limit()\n\n## .limit(limitNumber)\nAdds a row limit to query results.\n\n\tdb.limit(10);\n\t// Limits query results to 10 rows.\n\n## .limit(limitNumber, offsetNumber)\nAdds a row limit with an offset pointer position to query results.\n\n\tdb.limit(10, 30);\n\t// Limits query results to 10 rows, starting from the 30th row in the full matching set.\n\n# Query execution commands\n\nAfter execution of a query, all query conditions are cleared. Results are passed down to responseCallback function. The parameters handed over to responseCallback match exactly what the underlying node-mysql module produces. See documentation from https://github.com/felixge/node-mysql\n\n## .update(tableName, newData, responseCallback)\nProduces and executes UPDATE query. \n\n\tdb.update('people', { first_name: 'John', last_name: 'Smith' }, function(err) { ... });\n\t// This would produce: … UPDATE people SET first_name = 'John', last_name = 'Smith' …\n\n## .delete(tableName, responseCallback)\nProduces and executes DELETE query. Be sure to specify some WHERE clause components using .where() not to truncate an entire table. ✌\n\n\tdb.delete('people', function(err) { ... });\n\t\n## .insert(tableName, newData, responseCallback)\nProduces and executes a single-row INSERT query. \n\n\tdb.insert('people', { first_name: 'John', last_name: 'Smith' }, function(err, info) { ... });\n\t// This would produce: … INSERT INTO people SET first_name = 'John', last_name = 'Smith' …\n\n## .insert(tableName, [newData, newData, newData, …], responseCallback)\nProduces and executes a multi-row INSERT query. \n\t\n\tvar person1 = { first_name: 'John', last_name: 'Smith' };\n\tvar person2 = { first_name: 'Jason', last_name: 'Binder' };\n\tvar person3 = { first_name: 'Herbert', last_name: 'von Kellogg' };\n\tdb.insert('people', [person1, person2, person3], function(err, info) { ... });\n\t// This would produce: … INSERT INTO people (first_name, last_name) VALUES (('John','Smith'),('Jason','Binder'),('Herbert','von Kellogg')) …\n\n## .insert_ignore(tableName, newData, responseCallback, onDuplicateKeyClause)\nProduces and executes an INSERT IGNORE query. Note that the newData parameter can be either a string (produces single-row INSERT) or an array (produces multi-row INSERT). You can also specify an optional onDuplicateKeyClause, e.g.\n\t\n\tdb.insert_ignore('people', { first_name: 'John', last_name: 'Smith' }, function(err, info) { ... }, 'ON DUPLICATE KEY UPDATE duplicate_count = duplicate_count + 1');\n\t// This would produce: … INSERT IGNORE INTO people SET first_name = 'John', last_name = 'Smith' … ON DUPLICATE KEY UPDATE duplicate_count = duplicate_count + 1\n\n## .get(tableName, responseCallback)\nProduces and executes a SELECT query.\n\n\tdb.get('people', function(err, rows, fields) { ... });\n\t// This would produce: SELECT … FROM people …\n\n## .count(tableName, responseCallback)\nProduces and executes a SELECT query with count.\n\n\tdb.get('people', function(err, rows, fields) { ... });\n\t// This would produce: SELECT count(*) FROM people …\n\n## .query(sqlQueryString, responseCallback)\nProduces and executes a raw query. Note that while no set query conditions will be used in this query, they will all be reset nevertheless with the execution.\n\n\tdb.query('SHOW TABLES FROM test_database', function(err, results) { ... });\n\n## .ping()\nPings the connection. This is useful when extending idle timeouts.\n\n## ._last_query()\nReturns the last executed query as a string.\n\n## .connection()\nReturns the underlying database connection object, ultimately what https://github.com/felixge/node-mysql .createConnection() returns.\n\nPooling connections\n===================\n\nSingle or multiple connections can be pooled with the Pool object.\n\n\tvar Db = require('mysql-activerecord');\n\n\tvar pool = new Db.Pool({\n\t\tserver: 'localhost',\n\t\tusername: 'root',\n\t\tpassword: '12345',\n\t\tdatabase: 'test'\n\t});\n\t\n\tpool.getNewAdapter(function(db) {\n\t\tdb\n\t\t\t.where({ name: 'Martin' })\n\t\t\t.get('people', function(err, results, fields) {\n\t\t\t\tconsole.log(results);\n\t\t\t\tdb.releaseConnection();\n\t\t\t\t// do not do anything with db that has been released.\n\t\t\t});\n\t});\n\nSome more usage examples\n========================\n\nEstablishing a connection\n-------------------------\n\n\tvar Db = require('mysql-activerecord');\n\tvar db = new Db.Adapter({\n\t\tserver: 'localhost',\n\t\tusername: 'root',\n\t\tpassword: '12345',\n\t\tdatabase: 'test'\n\t});\n\t\nBasic SELECT query\n------------------\n\n\tdb.get('people', function(err, results, fields) {\n\t\tconsole.log(results);\n\t});\n\nINSERT query\n------------\n\t\n\tvar data = {\n\t\tname: 'Martin',\n\t\temail: 'martin@example.com'\n\t};\n\t\n\tdb.insert('people', data, function(err, info) {\n\t\tconsole.log('New row ID is ' + info.insertId);\n\t});\n\nINSERT IGNORE query with ON DUPLICATE KEY clause\n------------------------------------------------\n\t\n\tvar data = {\n\t\tname: 'Martin',\n\t\temail: 'martin@example.com'\n\t};\n\t\n\tdb.insert_ignore('people', data, function(err, info) {\n\t\tconsole.log('New row ID is ' + info.insertId);\n\t}, 'ON DUPLICATE KEY SET counter = counter + 1');\n\t\nSELECT query with WHERE clause\n------------------------------\n\n\tdb\n\t\t.where({ name: 'Martin' })\n\t\t.get('people', function(err, results, fields) {\n\t\t\tconsole.log(results);\n\t\t});\n\nSELECT query with custom fields, WHERE, JOIN and LIMIT\n------------------------------------------------------\n\n\tdb\n\t\t.select(['people.id', 'people.name', 'people.email', 'songs.title'])\n\t\t.join('songs', 'people.favorite_song_id', 'left')\n\t\t.where({\n\t\t\t'people.name': 'Martin',\n\t\t\t'songs.title': 'Yesterday'\n\t\t})\n\t\t.limit(5, 10)\n\t\t.order_by('people.name asc')\n\t\t.get('people', function(err, results, fields) {\n\t\t\tconsole.log(results);\n\t\t});\n\nBasic counting\n------------------------------------------------------\n\n\tdb\n\t\t.where({\n\t\t\t'people.name': 'Martin',\n\t\t\t'songs.title': 'Yesterday'\n\t\t})\n\t\t.count('people', function(err, results, fields) {\n\t\t\tconsole.log(results);\n\t\t});\n\nSELECT query with custom fields and GROUP BY\n--------------------------------------------\n\n\tdb\n\t\t.select('name, COUNT(name) AS name_count')\n\t\t.group_by('name')\n\t\t.order_by('name_count DESC')\n\t\t.get('people', function(err, results, fields) {\n\t\t\tconsole.log(results);\n\t\t});\n\nBasic UPDATE query\n------------------\n\t\n\tvar newData = {\n\t\tname: 'John',\n\t\temail: 'john@doe.com'\n\t};\n\t\n\tdb\n\t\t.where({ id: 1 });\n\t\t.update('people', newData, function(err) {\n\t\t\tif (!err) {\n\t\t\t\tconsole.log('Updated!');\n\t\t\t}\n\t\t});\n\nBasic DELETE query\n------------------\n\n\tdb\n\t\t.where({ id: 1 })\n\t\t.delete('people', function(err) {\n\t\t\tif (!err) {\n\t\t\t\tconsole.log('Deleted!')\n\t\t\t}\n\t\t});\n\n\nAdvanced WHERE conditions\n-------------------------\n\n\tdb\n\t\t.where(\"title not like '%Jackson%'\")\n\t\t.where(\"date_created > '2012-03-10'\")\n\t\t.where({ owner_id: 32 })\n\t\t.delete('records', function(err) {\n\t\t\tif (!err) {\n\t\t\t\tconsole.log('Deleted!')\n\t\t\t}\n\t\t});\n\n\nContribute\n==========\n\nGot a missing feature you'd like to use? Found a bug? Go ahead and fork this repo, build the feature and issue a pull request.\n\n\nLicence info\n============\n\nLicensed under the GPL license and MIT:\n\n* http://www.opensource.org/licenses/GPL-license.php\n* http://www.opensource.org/licenses/mit-license.php\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/martintajur/node-mysql-activerecord/issues"
  },
  "_id": "mysql-activerecord@0.8.6",
  "dist": {
    "shasum": "a4e6a6a420cc50e0410e30c68ef5e2ddcaf4b208"
  },
  "_from": "mysql-activerecord@*",
  "_resolved": "https://registry.npmjs.org/mysql-activerecord/-/mysql-activerecord-0.8.6.tgz"
}
